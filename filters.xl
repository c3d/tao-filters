// Filters module definition
//
// This module defines the filter primitives
//
// Copyright 2010-2011 Taodyne

module_description
    id "c90d3b0b-a461-48d4-a1e0-db212cd3e1ec"
    name "Filtering"
    import_name "Filters"
    description "A module to apply filters on imported images."
    author "Taodyne SAS"
    website "http://www.taodyne.com"
    version "1.0"

module_description "fr",
    name "Filtrage"
    description "Permet d'appliquer de nombreux filtres sur les images importÃ©es dans Tao."

import RenderToTexture 1.0

// -------------------------------------------------------------------------------------------------------------------
//   Filters primitives
// -------------------------------------------------------------------------------------------------------------------

gaussian iter:integer ->
    /**
    * Apply a gaussian filter on the current texture. It can be used to add blur on an image for instance.
    **/
    MAX_ITER := iter
    FILTER -> gaussian_filter
    iterate_render FILTER

mean iter:integer ->
    /**
    * Apply a mean filter on the current texture. It can be used to remove noise of an image for instance.
    **/
    MAX_ITER := iter
    FILTER -> mean_filter
    iterate_render FILTER

emboss iter:integer ->
    /**
    * Apply a embross filter on the current texture. It can be used to simulate 3D of an image for instance.
    **/
    MAX_ITER := iter
    FILTER -> emboss_filter
    iterate_render FILTER

sharpness iter:integer ->
    /**
    * Apply a sharpness filter on the current texture. It can be used to highlight details of an image for instance.
    **/
    MAX_ITER := iter
    FILTER -> sharpness_filter
    iterate_render FILTER

laplacian iter:integer ->
    /**
    * Apply a laplacian filter on the current texture. It can be used to detect oulines of an image for instance.
    **/    
    MAX_ITER := iter
    FILTER -> laplacian_filter
    iterate_render FILTER


// -------------------------------------------------------------------------------------------------------------------
//   Convolution filters 3x3
//   For further informations, see http://www.opengl.org/resources/code/samples/advanced/advanced97/notes/node152.html
// -------------------------------------------------------------------------------------------------------------------

gaussian_filter ->
    /**
    * Apply a gaussian convolution on the current texture.
    **/
    convolution_shader
    shader_set level  := 0.0
    shader_set kernel := (1.0 / 16.0; 2.0 / 16.0; 1.0 / 16.0; 2.0 / 16.0; 4.0 / 16.0; 2.0 / 16.0; 1.0 / 16.0; 2.0 / 16.0; 1.0 / 16.0)
    refresh 0.1

mean_filter ->
    /**
    * Apply a mean convolution on the current texture.
    **/
    convolution_shader
    shader_set level  := 0.0
    shader_set kernel := (1.0 / 9.0; 1.0 / 9.0; 1.0 / 9.0; 1.0 / 9.0; 1.0 / 9.0; 1.0 / 9.0; 1.0 / 9.0; 1.0 / 9.0; 1.0 / 9.0)
    refresh 0.1

emboss_filter ->
    /**
    * Apply a embross convolution on the current texture.
    **/
    convolution_shader
    shader_set level  := 0.5
    shader_set kernel := (2.0; 0.0; 0.0; 0.0; -1.0; 0.0; 0.0; 0.0; -1.0)
    refresh 0.1

sharpness_filter ->
    /**
    * Apply a sharpness convolution on the current texture.
    **/
    convolution_shader
    shader_set level  := 0.0
    shader_set kernel := (-1.0; -1.0; -1.0; -1.0; 9.0; -1.0; -1.0; -1.0; -1.0)
    refresh 0.1

laplacian_filter ->
    /**
    * Apply a laplacian convolution on the current texture.
    **/
    convolution_shader
    shader_set level  := 0.5
    shader_set kernel := (-1.0; -1.0; -1.0; -1.0; 8.0; -1.0; -1.0; -1.0; -1.0)
    refresh 0.1

convolution_shader ->
    /**
    * Define a common shader for convolution filters.
    **/
    shader_program
        shader_log
        vertex_shader <<

            varying vec4 baseColor;
            void main()
            {
                gl_Position    = ftransform();
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
                baseColor      = gl_Color;
            }
        >>
        fragment_shader <<#version 120
            #define KERNEL_SIZE 9 //Kernel size 3x3

            uniform float level; //Gray level
            uniform float width; //Texture width
            uniform float height; //Texture height
            uniform sampler2D colorMap;
            uniform float kernel[KERNEL_SIZE]; //Convolution kernel

            varying vec4 baseColor;

            vec2 offset[KERNEL_SIZE]; //Convolution offset
            float step_w = 1.0/width;
            float step_h = 1.0/height;

            void main (void)
            {
                int i = 0;
                vec4 sum = vec4(0.0);

                // Compute offset
                offset[0] = vec2(-step_w, -step_h);
                offset[1] = vec2(0.0, -step_h);
                offset[2] = vec2(step_w, -step_h);

                offset[3] = vec2(-step_w, 0.0);
                offset[4] = vec2(0.0, 0.0);
                offset[5] = vec2(step_w, 0.0);

                offset[6] = vec2(-step_w, step_h);
                offset[7] = vec2(0.0, step_h);
                offset[8] = vec2(step_w, step_h);

                //Apply filter to the current map
                for( i=0; i<KERNEL_SIZE; i++ )
                {
                    vec4 tmp = texture2D(colorMap, gl_TexCoord[0].st + offset[i]);
                    sum     += tmp * kernel[i];
                }

                //Add gray level
                sum += level;

                gl_FragColor = vec4(sum.rgb, 1.0) * baseColor;
            }
        >>

    shader_set colorMap := texture_unit
    shader_set width    := TEXTURE_WIDTH
    shader_set height   := TEXTURE_HEIGHT


// -------------------------------------------------------------------------------------------------------------------
//   Eroding filter
// -------------------------------------------------------------------------------------------------------------------

// Erosion center
ERODE_CENTER_X -> 0.5
ERODE_CENTER_Y -> 0.5

// Erosion radius
ERODE_RADIUS -> 1.0
ERODE_RADIUS := 1.0

// Erosion threshold
ERODE_THRESHOLD -> 0.5
ERODE_THRESHOLD := 0.5

// Erosion color
ERODE_R -> 2.0
ERODE_R := 2.0
ERODE_G -> 2.0
ERODE_G := 2.0
ERODE_B -> 2.0
ERODE_B := 2.0

erode_color r:real, g:real, b:real ->
    /**
    * Define erosion color.
    **/
    ERODE_R := r
    ERODE_G := g
    ERODE_B := b

erode_radius radius:real ->
    /**
    * Define erosion radius.
    **/
    ERODE_RADIUS := radius

erode x:real, y:real, threshold:real ->
    /**
    * Apply Erosion filter.
    **/
    ERODE_CENTER_X  := x
    ERODE_CENTER_Y  := y
    ERODE_THRESHOLD := threshold
    shader -> erode_shader
    render_to_texture shader
    refresh 0.1

erode_shader ->
    /**
    * Define shader to erode.
    **/
    shader_program
        shader_log
        vertex_shader <<
            varying vec4 baseColor;
            void main()
            {
                gl_Position    = ftransform();
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
                baseColor      = gl_Color;
            }
        >>
        fragment_shader <<

            // Filter parameters
            uniform sampler2D colorMap;
            uniform vec3 color;
            uniform float threshold;
            uniform float radius;
            uniform vec2 center;

            varying vec4 baseColor;

            // Erode main color according to the erode color and threshold
            void erode(vec3 mainColor, vec3 erodeColor)
            {
                if(erodeColor.r + threshold >= mainColor.r
                && erodeColor.g + threshold >= mainColor.g
                && erodeColor.b + threshold >= mainColor.b)
                {
                    if(erodeColor.r - threshold <= mainColor.r
                    && erodeColor.g - threshold <= mainColor.g
                    && erodeColor.b - threshold <= mainColor.b)
                    {
                        discard;
                    }
                }
            }

            void main()
            {
                vec4 mainColor = texture2D(colorMap, gl_TexCoord[0].st);

                vec3 erodeColor;
                // If color is not set, get center color to erode
                if(color.r > 1.0 || color.g > 1.0 || color.b > 1.0)
                    erodeColor = texture2D(colorMap, center).rgb;

                // Filtering inside a circle
                if((gl_TexCoord[0].s - center.x) * (gl_TexCoord[0].s - center.x) + (gl_TexCoord[0].t - center.y) * (gl_TexCoord[0].t - center.y) <= radius * radius)
                    erode(mainColor.rgb, erodeColor);

                gl_FragColor  = mainColor * baseColor;
            }
        >>

    shader_set colorMap  := texture_unit
    shader_set radius    := ERODE_RADIUS
    shader_set threshold := ERODE_THRESHOLD
    shader_set color     := (ERODE_R; ERODE_G; ERODE_B)
    shader_set center    := (ERODE_CENTER_X; ERODE_CENTER_Y)

// -------------------------------------------------------------------------------------------------------------------
//   Black & White filter
// -------------------------------------------------------------------------------------------------------------------

BLACK_WHITE_R -> 0.3
BLACK_WHITE_R := 0.3

BLACK_WHITE_G -> 0.3
BLACK_WHITE_G := 0.3

BLACK_WHITE_B -> 0.3
BLACK_WHITE_B := 0.3

black_and_white_levels ratio_r:real, ratio_g:real, ratio_b:real ->
    /**
    * Set RGB levels for black & white filter
    **/
    BLACK_WHITE_R := ratio_r
    BLACK_WHITE_G := ratio_g
    BLACK_WHITE_B := ratio_b

black_and_white ->
    /**
    * Apply Black & White filter
    **/
    shader -> black_and_white_shader
    render_to_texture shader
    refresh 0.1

black_and_white_shader ->
    /**
    * Define black & white shader
    **/
    shader_program
        shader_log
        vertex_shader <<
            void main()
            {
                gl_Position    = ftransform();
                gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
            }
            >>

        fragment_shader <<
            // Filter parameters
            uniform sampler2D colorMap;
            uniform float ratio_r;
            uniform float ratio_g;
            uniform float ratio_b;

            void main()
            {
                vec4 color = texture2D( colorMap, gl_TexCoord[0].st );

                // Define color levels
                vec3 red   = vec3(color.r, color.r, color.r);
                vec3 green = vec3(color.g, color.g, color.g);
                vec3 blue  = vec3(color.b, color.b, color.b);

                gl_FragColor = vec4(ratio_r * red + ratio_g * green +  ratio_b * blue, 1.0);
            }
            >>

    shader_set colorMap := texture_unit
    shader_set ratio_r  := BLACK_WHITE_R
    shader_set ratio_g  := BLACK_WHITE_G
    shader_set ratio_b  := BLACK_WHITE_B


