// ****************************************************************************
//  filters.xl                                                     Tao project 
// ****************************************************************************
// 
//   File Description:
// 
//      Define the image filtering primitives:
//      - Gaussian blur (two-pass)
//      - Mean
//      - Laplacian
//      - Emboss
//      - Sharpness
// 
// 
// 
// ****************************************************************************
// This software is property of Taodyne SAS - Confidential
// Ce logiciel est la propriété de Taodyne SAS - Confidentiel
//  (C) 2012 Baptiste Soulisse <baptiste.soulisse@taodyne.com>
//  (C) 2013 Christophe de Dinechin <christophe@taodyne.com>
//  (C) 2012-2013 Taodyne SAS
// ****************************************************************************

module_description
    id "c90d3b0b-a461-48d4-a1e0-db212cd3e1ec"
    name "Filtering"
    import_name "Filters"
    description "A module to apply filters on imported images."
    author "Taodyne SAS"
    website "http://www.taodyne.com"
    version 1.008

module_description "fr",
    name "Filtrage"
    description "Permet d'appliquer de nombreux filtres sur les images importées dans Tao."



// ============================================================================
// 
//    Filter primitives
// 
// ============================================================================

gaussian Radius:integer ->
// ----------------------------------------------------------------------------
//   Apply a two-pass gaussian filter with the given radius
// ----------------------------------------------------------------------------
    if Radius > 0 then
        render_to_texture { gaussian_h texture_width, texture_height, Radius }
        render_to_texture { gaussian_v texture_width, texture_height, Radius }


gaussian RH:integer, RV:integer ->
// ----------------------------------------------------------------------------
//    Apply a gaussian filter with different vertical and horizontal radii
// ----------------------------------------------------------------------------
    if RH > 0 then
        render_to_texture { gaussian_h texture_width, texture_height, RH }
    if RV > 0 then
        render_to_texture { gaussian_v texture_width, texture_height, RV }


gaussian_3x3 iter:integer ->
// ----------------------------------------------------------------------------
//    Apply a Gaussian 3x3 kernel
// ----------------------------------------------------------------------------
// The Gaussian 3x3 filter is special hard-coded case
    gaussian_3x3_iter with 1..iter


gaussian_3x3_iter i ->
// ----------------------------------------------------------------------------
//   Apply an iteration of the Gaussian filter
// ----------------------------------------------------------------------------
    render_to_texture {gaussian_3x3 texture_width, texture_height}


mean iter:integer ->
// ----------------------------------------------------------------------------
//    Apply a mean filter on the current texture
// ----------------------------------------------------------------------------
// The mean filter can be used to remove noise of an image
    mean_iter with 1..iter

mean_iter i ->
// ----------------------------------------------------------------------------
//   Apply an iteration of the mean filter
// ----------------------------------------------------------------------------
    render_to_texture {mean texture_width, texture_height}


emboss iter:integer ->
// ----------------------------------------------------------------------------
//   Apply emboss filter on current texture
// ----------------------------------------------------------------------------
// This filter can be used to simulate a kind of 3D effect on an image
    emboss_iter with 1..iter


emboss_iter i ->
// ----------------------------------------------------------------------------
//   Apply an iteration of the emboss filter
// ----------------------------------------------------------------------------
    render_to_texture {emboss texture_width, texture_height}


sharpness iter:integer ->
// ----------------------------------------------------------------------------
//    Apply a sharpness filter to the current texture
// ----------------------------------------------------------------------------
//  The sharpness filter can be used to highlight details of an image
    sharpness_iter with 1..iter


sharpness_iter i ->
// ----------------------------------------------------------------------------
//    Apply an iteration of a sharpness filter
// ----------------------------------------------------------------------------
    render_to_texture {sharpness texture_width, texture_height}


laplacian iter:integer ->
// ----------------------------------------------------------------------------
//   Apply a Laplacian filter 'iter' times
// ----------------------------------------------------------------------------
//   A Laplacian filter can be used to detect the outlines of an image
    laplacian_iter with 1..iter


laplacian_iter i ->
// ----------------------------------------------------------------------------
//   Apply an iteration of the Laplacian filter on the current texture
// ----------------------------------------------------------------------------
    render_to_texture {laplacian texture_width, texture_height}


erode x:real, y:real, threshold:real ->
// ----------------------------------------------------------------------------
//    Apply an erosion filter
// ----------------------------------------------------------------------------
    render_to_texture {erode x, y, threshold}


black_and_white ->
// ----------------------------------------------------------------------------
//   Apply a black-and-white filter
// ----------------------------------------------------------------------------
    render_to_texture black_and_white



// ============================================================================
// 
//   Shadows
// 
// ============================================================================

shadow_angle            -> 115.0
shadow_offset           -> 5.0
shadow_depth            -> 5.0
shadow_blur             -> 5.0
shadow_color            -> "black"
shadow_opacity          -> 0.75
shadow_filter_red       -> 0.0
shadow_filter_green     -> 0.0
shadow_filter_blue      -> 0.0
shadow_filter_alpha     -> 1.0

shadow_angle   A:real   -> shadow_angle   := A
shadow_offset  D:real   -> shadow_offset  := D
shadow_depth   Z:real   -> shadow_depth   := Z
shadow_blur    B:real   -> shadow_blur    := B
shadow_color   C:text   -> shadow_color   := C
shadow_opacity O:real   -> shadow_opacity := O
shadow_filter  R:real, G:real, B:real, A:real ->
    shadow_filter_red   := R
    shadow_filter_green := G
    shadow_filter_blue  := B
    shadow_filter_alpha := A

shadow_source           -> 0
shadow_texture          -> 0


shadow_texture W:integer, H:integer, Body ->
// ----------------------------------------------------------------------------
//   Render the shadow in a texture
// ----------------------------------------------------------------------------
    shadow_source := frame_texture (W, H, { blend_function "ONE", "ZERO"; Body})
    shadow_texture := render_to_texture
        shader_program
            vertex_shader <<
                void main(void)
                {
                    gl_Position = ftransform();
                    gl_FrontColor = gl_Color;
                    gl_BackColor = gl_Color;
                    gl_TexCoord[0] = gl_TextureMatrix[0] * gl_MultiTexCoord0;
                }
            >>
            fragment_shader <<
                uniform sampler2D texture;
                uniform vec4      filter;
                void main(void)
                {
                    vec2  pos    = gl_TexCoord[0].xy;
                    float shadow = dot(texture2D(texture, pos), filter);
                    gl_FragColor = shadow * gl_Color;
                }
            >>
        shader_set filter := shadow_filter_red, shadow_filter_green, shadow_filter_blue, shadow_filter_alpha
        color shadow_color, shadow_opacity
    if shadow_blur > 0.0 then
        gaussian integer(shadow_blur)


shadow X:real, Y:real, W:integer, H:integer, Body ->
// ----------------------------------------------------------------------------
//   Draw the Body with a drop shadow
// ----------------------------------------------------------------------------
    locally
        shadow_texture W, H, Body
        color "white"
        locally
            shadow_radians -> shadow_angle * pi / 180
            translate shadow_offset * sin shadow_radians, shadow_offset * cos shadow_radians, -shadow_depth
            rectangle X, Y, W, H
        texture shadow_source
        rectangle X, Y, W, H


// ============================================================================
// 
//   Render to Texture
// 
// ============================================================================

TEXTURE_WIDTH   -> 0
TEXTURE_HEIGHT  -> 0
TEXTURE_ID      -> 0

render_to_texture RENDER_CODE ->
// ----------------------------------------------------------------------------
//   Render 'RENDER_CODE' into a new texture
// ----------------------------------------------------------------------------
//   Note that the texture is rendered in the current texture unit, but
//   that within the body of frame_texture, we render with a single
//   texture and map this unique texture to texture 0.

    TEXTURE_WIDTH := texture_width
    TEXTURE_HEIGHT := texture_height
    TEXTURE_ID := texture

    frame_texture TEXTURE_WIDTH, TEXTURE_HEIGHT,
        color "white"
        texture TEXTURE_ID
        blend_function "ONE", "ZERO"
        RENDER_CODE
        rectangle 0, 0, TEXTURE_WIDTH, TEXTURE_HEIGHT
